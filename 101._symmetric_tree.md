###101. Symmetric Tree

é¢˜ç›®:

<https://leetcode.com/problems/symmetric-tree/>


éš¾åº¦:

Easy


ä¸¤æ£µæ ‘symmetricï¼Œ æœ‰å‡ ç§å¯èƒ½ï¼š

- å‡ä¸ºnone ï¼Œsymmetric
- å·¦å­©å­ï¼Œå³å­©å­éƒ½ä¸å­˜åœ¨ï¼Œå¹¶ä¸”å€¼ç›¸ç­‰ï¼Œ symmetric
- å³å­æ ‘ å’Œ å¦ä¸€æ£µæ ‘çš„å·¦å­æ ‘ç›¸ç­‰ï¼Œå·¦å­æ ‘ å’Œå¦ä¸€é¢—æ ‘çš„å³å­æ ‘ç›¸ç­‰ ğŸŒ²


```python
class Solution:
    def check(self,t1,t2):
        if t1==None or t2==None:
            if t1==t2:
                return True
            else:
                return False
        if t1.val==t2.val:
            return self.check(t1.left,t2.right) and self.check(t1.right,t2.left)
        else:
            return False
        
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if root is None:
            return True
       
        else:
            return self.check(root.left,root.right) 
```

å…¶å®å‡½æ•°ä¸åº”è¯¥å®šä¹‰ä¸ºsymmetricï¼Œåº”è¯¥å®šä¹‰ä¸ºequalï¼Ÿæ›´åˆé€‚ã€‚

Non-recursive version:
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
         if(!root) return true;
         queue<TreeNode *> check;
         check.push(root->left);
         check.push(root->right);
         while(!check.empty())
         {
             TreeNode *n1=check.front();
             check.pop();
             TreeNode *n2=check.front();
             check.pop();
             
             if( (!n1 && n2) || (n1 && !n2) ) return false;
             if(n1&&n2)
             { 
                 if(n1->val != n2->val) return false;
                 check.push(n1->left);
                 check.push(n2->right);
                 check.push(n1->right);
                 check.push(n2->left);
             }
         }//while ends
        return true;
}
};
```

```python
def isSymmetric(self, root):
      if root is None:
          return True
      stack = [(root.left, root.right)]
      while stack:
          left, right = stack.pop()
          if left is None and right is None:
              continue
          if left is None or right is None:
              return False
          if left.val == right.val:
              stack.append((left.left, right.right))
              stack.append((left.right, right.left))
          else:
              return False
      return True
 ```     
 using `deque` as `queuq` in python 
 ```python 
 class Solution:
    def isSymmetric(self, root):
        if not root:
            return True
        
        q = collections.deque([root.left, root.right])
        
        while q:
            t1, t2 = q.popleft(), q.popleft()

            if not t1 and not t2:
                continue
            elif (not t1 or not t2) or (t1.val != t2.val):
                return False
            
            q += [t1.left, t2.right, t1.right, t2.left]
            
        return True
```
